# Environment
# ===========

# XDG Base Directory Specificatio
# --------------------------------

# See
# https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html

export XDG_CONFIG_HOME="${HOME}/.config"
export XDG_CACHE_HOME="${HOME}/.cache"
export XDG_DATA_HOME="${HOME}/.local/share"

# VIM Redirection
# ---------------

# See https://tlvince.com/vim-respect-xdg

export VIMINIT='let $MYVIMRC="$XDG_CONFIG_HOME/vim/vimrc" | source $MYVIMRC'

# Tmux Redirection
# ----------------

# Non-ideal solution of setting tmux to an alias the specifies the config file
alias tmux='tmux -f ~/.config/tmux/tmux.conf'

# Less Redirection
# ----------------
mkdir -p "${XDG_CACHE_HOME}"/less
export LESSHISTFILE="${XDG_CACHE_HOME}/less/history"

# History
# =======
mkdir -p "${XDG_DATA_HOME}/bash"
HISTFILE="${XDG_DATA_HOME}/bash/history"
HISTSIZE=1000
SAVEHIST=1000

# Prompt
# ======

# Colors
# ------

# ## Palette
readonly CLR_BLACK=0
readonly CLR_MAROON=1
readonly CLR_GREEN=2
readonly CLR_OLIVE=3
readonly CLR_NAVY=4
readonly CLR_PURPLE=5
readonly CLR_TEAL=6
readonly CLR_SILVER=7
readonly CLR_GREY=8
readonly CLR_RED=9
readonly CLR_LIME=10
readonly CLR_YELLOW=11
readonly CLR_BLUE=12
readonly CLR_FUCHSIA=13
readonly CLR_AQUA=14
readonly CLR_WHITE=15

# ## Scheme
readonly CLR_FG_BLACK=$(tput setaf ${CLR_BLACK})
readonly CLR_FG_MAROON=$(tput setaf ${CLR_MAROON})
readonly CLR_FG_GREEN=$(tput setaf ${CLR_GREEN})
readonly CLR_FG_GREY=$(tput setaf ${CLR_GREY})
readonly CLR_FG_RED=$(tput setaf ${CLR_RED})
readonly CLR_FG_LIME=$(tput setaf ${CLR_LIME})
readonly CLR_FG_BLUE=$(tput setaf ${CLR_BLUE})
readonly CLR_FG_WHITE=$(tput setaf ${CLR_WHITE})
readonly CLR_BG_MAROON=$(tput setab ${CLR_MAROON})
readonly CLR_BG_GREEN=$(tput setab ${CLR_GREEN})
readonly CLR_BG_YELLOW=$(tput setab ${CLR_YELLOW})
readonly CLR_BG_BLUE=$(tput setab ${CLR_BLUE})
readonly CLR_BG_WHITE=$(tput setab ${CLR_WHITE})
readonly CLR_RESET=$(tput sgr0)

# Git
# ---
git_path=$(which git)

if [[ "$?" -ne 0 ]]; then
  git_path=''
fi

# ### print_trans_right
print_trans_right() {
  clr_left="${1}"
  clr_right="${2}"

  printf "$(tput setaf ${clr_left})$(tput setab ${clr_right})\ue0b0"
}

# ### print_git_xy_stats
print_git_xy_stats() {
  code="${1}"
  num_x="${2}"
  num_y="${3}"
  res=''

  if [[ "${num_x}" -gt 0 || "${num_y}" -gt 0 ]]; then
    res+=" ${CLR_FG_MAROON}${code}"

    if [[ "${num_x}" -gt 0 ]]; then res+="${CLR_FG_GREEN}${num_x}"; fi
    if [[ "${num_y}" -gt 0 ]]; then
      res+="${CLR_FG_MAROON}:${CLR_FG_MAROON}${num_y}"
    fi
  fi

  printf "${res}"
}

# ### print_git_status
print_git_status() {
  # Print the leading spacer
  printf ' '

  # Git is installed
  if [[ -n "${git_path}" ]]; then
    stat=$("${git_path}" status --porcelain=v2 --branch 2> /dev/null)

    # Inside a repo so generate and output the status
    if [[ "$?" -eq 0 ]]; then
      # Parse the branch and fallback to a default value
      branch=$(printf "${stat}" | grep '^# branch.head ' -m 1 | cut -b 15-)

      # Parse ahead and behind
      ab=$(printf "${stat}" | grep '^# branch.ab ' -m 1)
      a=$(printf "${ab}" | cut -d '+' -f 2 | cut -d ' ' -f 1)
      b=$(printf "${ab}" | cut -d '-' -f 2)

      # Parse the changes
      num_a=$(printf "${stat}" | grep '^[12u] A' -c)
      num_mx=$(printf "${stat}" | grep -E '^[12u] M' -c)
      num_my=$(printf "${stat}" | grep -E '^[12u] .M' -c)
      num_dx=$(printf "${stat}" | grep -E '^[12u] D' -c)
      num_dy=$(printf "${stat}" | grep -E '^[12u] .D' -c)
      num_rx=$(printf "${stat}" | grep -E '^[12u] R' -c)
      num_ry=$(printf "${stat}" | grep -E '^[12u] .R' -c)
      num_cx=$(printf "${stat}" | grep -E '^[12u] C' -c)
      num_cy=$(printf "${stat}" | grep -E '^[12u] .C' -c)
      num_u=$(printf "${stat}" | grep '^? ' -c)
      total=$(printf "${stat}" | grep '^[12u?] ' -c)

      # Construct the stats
      stats=''

      if [[ -n "${a}" && "${a}" -gt 0 ]]; then
        stats+=" ${CLR_FG_MAROON}↑${a}"
      fi

      if [[ -n "${b}" && "${b}" -gt 0 ]]; then
        stats+=" ${CLR_FG_MAROON}↓${b}"
      fi

      stats+=$(print_git_xy_stats 'a' "${num_a}")
      stats+=$(print_git_xy_stats 'm' "${num_mx}" "${num_my}")
      stats+=$(print_git_xy_stats 'd' "${num_dx}" "${num_dy}")
      stats+=$(print_git_xy_stats 'r' "${num_rx}" "${num_ry}")
      stats+=$(print_git_xy_stats 'c' "${num_cx}" "${num_cy}")
      stats+=$(print_git_xy_stats 'u' "${num_u}")

      # Output the stats

      # No changes, so the branch is clean. It may still be ahead or behind.
      if [[ "${total}" -eq 0 ]]; then
        print_trans_right "${CLR_BLACK}" "${CLR_GREEN}"
        printf " ${CLR_FG_WHITE}${branch} "

        if [[ -z "${stats}" ]]; then
          print_trans_right "${CLR_GREEN}" "${CLR_BLUE}"
        else
          print_trans_right "${CLR_GREEN}" "${CLR_WHITE}"
        fi

      # Changes, so the branch is dirty. It may also be ahead or behind.
      else
        print_trans_right "${CLR_BLACK}" "${CLR_MAROON}"
        printf "${CLR_FG_WHITE} \ue0a0 ${branch} "
        print_trans_right "${CLR_MAROON}" "${CLR_WHITE}"

      fi

      # A clean branch may have stats because it is ahead or behind. A dirty
      # branch may not have stats if there are changes we didn't check for,
      # i.e., total > 0 and stats = ''.
      if [[ -n "${stats}" ]]; then
        printf "${CLR_BG_WHITE}${stats} "
        print_trans_right "${CLR_WHITE}" "${CLR_BLUE}"
      fi
    else
      print_trans_right "${CLR_BLACK}" "${CLR_BLUE}"
    fi
  else
    print_trans_right "${CLR_BLACK}" "${CLR_BLUE}"
  fi

  # If we are in a repo we have to output a trailing space, and if we are
  # not in a repo or Git is not installed, we have to output a space
  printf "${CLR_RESET}"
}

# Prompt Parts
# ------------

print_last_status() {
  if [[ "$?" = '0' ]]; then
    printf "${CLR_FG_LIME}√"
  else
    printf "${CLR_FG_RED}$?"
  fi
}

# Each part will be expanded once when assembled to form the prompt. If any
# portion of a part needs to be expanded each time the prompt is written,
# simply don't expand, or escape the $ for those portions.
PS_LAST='$(print_last_status)'
PS_USER="${CLR_FG_LIME}\u"
PS_SEP="${CLR_FG_RED}@"
PS_HOST="${CLR_FG_LIME}\h"
PS_DIR="${CLR_FG_BLUE}\w"
PS_GIT='$(print_git_status)'
PS_SYM="${CLR_BG_BLUE} ${CLR_FG_WHITE}bash "
PS_SYM+="$(print_trans_right ${CLR_BLUE} ${CLR_BLACK})"
PS_SYM+="${CLR_RESET} ${CLR_FG_GREY}\\$"

PS1="${PS_LAST} ${PS_USER}${PS_SEP}${PS_HOST} "
PS1+="${PS_DIR}${PS_GIT}${PS_SYM}${CLR_RESET} "

# Aliases
# =======

# ls
# --
alias ls='ls --color=auto'
alias l='ls -al'
alias la='ls -A'
alias ll='ls -l'

# cp
# --
alias cp='cp -i'

# rm
# --
alias rm='rm -i'

# tmux
# ----
alias t='tmux'

# vim
# ---
alias v='vim'
alias vv='v -u NONE'

